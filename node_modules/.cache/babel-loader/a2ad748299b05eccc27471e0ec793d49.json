{"ast":null,"code":"// Utilities\nimport { computed, ref, watch } from 'vue';\nimport { getCurrentInstance, toKebabCase } from \"../util/index.mjs\";\nimport { useToggleScope } from \"./toggleScope.mjs\"; // Types\n\n// Composables\nexport function useProxiedModel(props, prop, defaultValue) {\n  let transformIn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : v => v;\n  let transformOut = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : v => v;\n  const vm = getCurrentInstance('useProxiedModel');\n  const internal = ref(props[prop]);\n  const kebabProp = toKebabCase(prop);\n  const checkKebab = kebabProp !== prop;\n  const isControlled = checkKebab ? computed(() => {\n    var _vm$vnode$props, _vm$vnode$props2, _vm$vnode$props3, _vm$vnode$props4;\n    void props[prop];\n    return !!(((_vm$vnode$props = vm.vnode.props) != null && _vm$vnode$props.hasOwnProperty(prop) || (_vm$vnode$props2 = vm.vnode.props) != null && _vm$vnode$props2.hasOwnProperty(kebabProp)) && ((_vm$vnode$props3 = vm.vnode.props) != null && _vm$vnode$props3.hasOwnProperty(`onUpdate:${prop}`) || (_vm$vnode$props4 = vm.vnode.props) != null && _vm$vnode$props4.hasOwnProperty(`onUpdate:${kebabProp}`)));\n  }) : computed(() => {\n    var _vm$vnode$props5, _vm$vnode$props6;\n    void props[prop];\n    return !!((_vm$vnode$props5 = vm.vnode.props) != null && _vm$vnode$props5.hasOwnProperty(prop) && (_vm$vnode$props6 = vm.vnode.props) != null && _vm$vnode$props6.hasOwnProperty(`onUpdate:${prop}`));\n  });\n  useToggleScope(() => !isControlled.value, () => {\n    watch(() => props[prop], val => {\n      internal.value = val;\n    });\n  });\n  const model = computed({\n    get() {\n      return transformIn(isControlled.value ? props[prop] : internal.value);\n    },\n    set(newValue) {\n      if (transformIn(isControlled.value ? props[prop] : internal.value) === newValue) {\n        return;\n      }\n      newValue = transformOut(newValue);\n      internal.value = newValue;\n      vm == null ? void 0 : vm.emit(`update:${prop}`, newValue);\n    }\n  });\n  Object.defineProperty(model, 'externalValue', {\n    get: () => isControlled.value ? props[prop] : internal.value\n  });\n  return model;\n}","map":{"version":3,"mappings":"AAAA;AACA,SAASA,QAAT,EAAmBC,GAAnB,EAAwBC,KAAxB,QAAqC,KAArC;SACSC,kB,EAAoBC,W;SACpBC,c,6BAET;;AAKA;AACA,OAAO,SAASC,eAAT,CAKLC,KALK,EAMLC,IANK,EAOLC,YAPK,EAUL;EAAA,IAFAC,WAEA,uEAF+CC,CAAD,IAAYA,CAE1D;EAAA,IADAC,YACA,uEAD+CD,CAAD,IAAYA,CAC1D;EACA,MAAME,EAAE,GAAGV,kBAAkB,CAAC,iBAAD,CAA7B;EACA,MAAMW,QAAQ,GAAGb,GAAG,CAACM,KAAK,CAACC,IAAD,CAAN,CAApB;EACA,MAAMO,SAAS,GAAGX,WAAW,CAACI,IAAD,CAA7B;EACA,MAAMQ,UAAU,GAAGD,SAAS,KAAKP,IAAjC;EAEA,MAAMS,YAAY,GAAGD,UAAU,GAC3BhB,QAAQ,CAAC,MAAM;IAAA;IACf,KAAKO,KAAK,CAACC,IAAD,CAAV;IACA,OAAO,CAAC,EACN,CAAC,qBAAE,CAACU,KAAH,CAASX,KAAT,6BAAgBY,cAAhB,CAA+BX,IAA/B,yBAAwCK,EAAE,CAACK,KAAH,CAASX,KAAjD,aAAwCa,iBAAgBD,cAAhB,CAA+BJ,SAA/B,CAAzC,MACC,sBAAE,CAACG,KAAH,CAASX,KAAT,8BAAgBY,cAAhB,CAAgC,YAAWX,IAAK,EAAhD,yBAAsDK,EAAE,CAACK,KAAH,CAASX,KAA/D,aAAsDc,iBAAgBF,cAAhB,CAAgC,YAAWJ,SAAU,EAArD,CADvD,CADM,CAAR;EAID,CANS,CADmB,GAQ3Bf,QAAQ,CAAC,MAAM;IAAA;IACf,KAAKO,KAAK,CAACC,IAAD,CAAV;IACA,OAAO,CAAC,EAAE,sBAAE,CAACU,KAAH,CAASX,KAAT,8BAAgBY,cAAhB,CAA+BX,IAA/B,yBAAwCK,EAAE,CAACK,KAAH,CAASX,KAAjD,aAAwCe,iBAAgBH,cAAhB,CAAgC,YAAWX,IAAK,EAAhD,CAA1C,CAAR;EACD,CAHS,CARZ;EAaAH,cAAc,CAAC,MAAM,CAACY,YAAY,CAACM,KAArB,EAA4B,MAAM;IAC9CrB,KAAK,CAAC,MAAMK,KAAK,CAACC,IAAD,CAAZ,EAAoBgB,GAAG,IAAI;MAC9BV,QAAQ,CAACS,KAAT,GAAiBC,GAAjB;IACD,CAFI,CAAL;EAGD,CAJa,CAAd;EAMA,MAAMC,KAAK,GAAGzB,QAAQ,CAAC;IACrB0B,GAAG,GAAS;MACV,OAAOhB,WAAW,CAACO,YAAY,CAACM,KAAb,GAAqBhB,KAAK,CAACC,IAAD,CAA1B,GAAmCM,QAAQ,CAACS,KAA7C,CAAlB;IACD,CAHoB;IAIrBI,GAAG,CAAEC,QAAF,EAAY;MACb,IAAIlB,WAAW,CAACO,YAAY,CAACM,KAAb,GAAqBhB,KAAK,CAACC,IAAD,CAA1B,GAAmCM,QAAQ,CAACS,KAA7C,CAAX,KAAmEK,QAAvE,EAAiF;QAC/E;MACD;MACDA,QAAQ,GAAGhB,YAAY,CAACgB,QAAD,CAAvB;MACAd,QAAQ,CAACS,KAAT,GAAiBK,QAAjB;MACAf,EAAE,QAAF,cAAE,CAAEgB,IAAJ,CAAU,UAASrB,IAAK,EAAxB,EAA2BoB,QAA3B;IACD;EAXoB,CAAD,CAAtB;EAcAE,MAAM,CAACC,cAAP,CAAsBN,KAAtB,EAA6B,eAA7B,EAA8C;IAC5CC,GAAG,EAAE,MAAMT,YAAY,CAACM,KAAb,GAAqBhB,KAAK,CAACC,IAAD,CAA1B,GAAmCM,QAAQ,CAACS;EADX,CAA9C;EAIA,OAAOE,KAAP;AACD","names":["computed","ref","watch","getCurrentInstance","toKebabCase","useToggleScope","useProxiedModel","props","prop","defaultValue","transformIn","v","transformOut","vm","internal","kebabProp","checkKebab","isControlled","vnode","hasOwnProperty","_vm$vnode$props2","_vm$vnode$props4","_vm$vnode$props6","value","val","model","get","set","newValue","emit","Object","defineProperty"],"sources":["../../src/composables/proxiedModel.ts"],"sourcesContent":["// Utilities\nimport { computed, ref, watch } from 'vue'\nimport { getCurrentInstance, toKebabCase } from '@/util'\nimport { useToggleScope } from '@/composables/toggleScope'\n\n// Types\nimport type { Ref } from 'vue'\n\ntype InnerVal<T> = T extends any[] ? Readonly<T> : T\n\n// Composables\nexport function useProxiedModel<\n  Props extends object & { [key in Prop as `onUpdate:${Prop}`]: ((val: any) => void) | undefined },\n  Prop extends Extract<keyof Props, string>,\n  Inner = Props[Prop],\n> (\n  props: Props,\n  prop: Prop,\n  defaultValue?: Props[Prop],\n  transformIn: (value?: Props[Prop]) => Inner = (v: any) => v,\n  transformOut: (value: Inner) => Props[Prop] = (v: any) => v,\n) {\n  const vm = getCurrentInstance('useProxiedModel')\n  const internal = ref(props[prop]) as Ref<Props[Prop]>\n  const kebabProp = toKebabCase(prop)\n  const checkKebab = kebabProp !== prop\n\n  const isControlled = checkKebab\n    ? computed(() => {\n      void props[prop]\n      return !!(\n        (vm.vnode.props?.hasOwnProperty(prop) || vm.vnode.props?.hasOwnProperty(kebabProp)) &&\n        (vm.vnode.props?.hasOwnProperty(`onUpdate:${prop}`) || vm.vnode.props?.hasOwnProperty(`onUpdate:${kebabProp}`))\n      )\n    })\n    : computed(() => {\n      void props[prop]\n      return !!(vm.vnode.props?.hasOwnProperty(prop) && vm.vnode.props?.hasOwnProperty(`onUpdate:${prop}`))\n    })\n\n  useToggleScope(() => !isControlled.value, () => {\n    watch(() => props[prop], val => {\n      internal.value = val\n    })\n  })\n\n  const model = computed({\n    get (): any {\n      return transformIn(isControlled.value ? props[prop] : internal.value)\n    },\n    set (newValue) {\n      if (transformIn(isControlled.value ? props[prop] : internal.value) === newValue) {\n        return\n      }\n      newValue = transformOut(newValue)\n      internal.value = newValue\n      vm?.emit(`update:${prop}`, newValue)\n    },\n  }) as any as Ref<InnerVal<Inner>> & { readonly externalValue: Props[Prop] }\n\n  Object.defineProperty(model, 'externalValue', {\n    get: () => isControlled.value ? props[prop] : internal.value,\n  })\n\n  return model\n}\n"]},"metadata":{},"sourceType":"module"}